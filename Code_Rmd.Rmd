---
title: "Graph Analysis Project"
author: 
- "NASR Rodrigue"
- "NENOVSKY Nikola"
date: "2024-03-28"
output: 
  pdf_document:
    toc: yes
  html_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Research question: Study of a network formation mechanism

*In this project, you will investigate a dyadic mechanism driving the formation of a real network. This mechanism can be related to assortativity or dissortativity on a node attribute (similar or dissimilar individuals tend to be connected), to the sociability or popularity of a node attribute (some individuals connect to more people or receive more connections), or to another network variable (individuals connected through another network tend to be connected). Please leave the instructions in italic. Attach your code as a RmD file.*

## Introduction and data presentation

#Insert intro and data presentation

## Data preparation

```{r}
library(tidyverse)
library(igraph)
library(igraphdata)
library(RColorBrewer)
library(dplyr)
library(ggplot2)
```

```{r}
#Importing the Data
setwd("C:/Users/Rodrigue/Desktop/X/rodrigue/Master/Master 2/S2/Graph analysis/Project")
currencies_data <- read.delim("flandreau_jobst_internationalcurrencies_data.txt", skip = 9)
```

First, we retrieve the countries information.

```{r}
#Countries Informations
countries_infos <- currencies_data[,c("country_A","gold","debtburden","rlong","rshort1900","rshort1890","rgdp","rgdpcap","poldemo","coverage")]
countries_infos <- unique(countries_infos)
```

Let's identify if the country is a colonizer or not

```{r}
#Finding if a country is a colonizer of other countries
colonizer <- graph_data[,c("country_B","colony")]
grouped_colonizer <- colonizer %>%
  group_by(country_B) %>%
  summarize(Sum_colony = sum(colony))
grouped_colonizer$is_colonizer <- ifelse(grouped_colonizer$Sum_colony != 0 ,1 ,0)
# Add the variable is_colonizer to countries_info
countries_infos <- countries_infos %>%
  left_join(grouped_colonizer[,c("country_B","is_colonizer")], by = c("country_A" = "country_B"))
```

Then, we will create a directed graph with our dataframe.

We will also divide weights based on the trade amount, which will be used for our first plot.

```{r}
graph_data <- currencies_data[currencies_data$bitrade != 0 ,c("country_A","country_B","bitrade","colony")]
quantile(graph_data$bitrade)
```

Based on the quantiles, we divide into 3 categories:

1.  Below 12000 USD

2.  Between 12000 USD and 51000 USD

3.  Greater than 51000 USD

```{r}
breakpoints <- c(-Inf, 12000, 51000, Inf)
graph_data$category <- cut(graph_data$bitrade, breaks = breakpoints, labels = c("green", "blue", "red"))

graph <- graph_from_data_frame(graph_data,directed = TRUE, vertices=countries_infos)
E(graph)$weight <- graph_data$bitrade
E(graph)$colony <- graph_data$colony
graph$layout <- layout_nicely(graph)
```

### First plot

```{r}
par(mfrow=c(1,1), mar=rep(0,4))
plot(
  graph,
  vertex.size = 3,
  vertex.color = "blue",
  vertex.frame.color = "blue",
  vertex.label.cex = 0.8,
  vertex.label.color = "black",
  vertex.label.dist = 0.3,
  edge.width = 0.1,
  edge.cex = 1,
  edge.color = as.character(graph_data$category),
)
```

As we can see, the total trade is higher in the center of the graph (blue and red edges), which shows that there is a group of central countries which have a big number of connections with a high trade value, while being the central home of the currency implied in the trade.

## Centralities

### Pagerank centrality

We want to measure how much the importance of a node in our graph depends on the importance of its neighbors. To do so, instead of using eigenvector centrality,since our graph is directed, we will use pagerank centrality.

Let's compute it for all nodes, then we check its correlation with the two variables rgdp (log 1900 real gdp) and gold (1 if country_A has a currency convertible in gold in 1900 and 0 otherwise.)

We expect there to be a correlation between rgdp and pagerank centrality: Indeed, economically stronger countries often have more resources to invest in infrastructure, technology and international relations, which can lead to greater connectivity and influence across the world. This may be due to their location and their influential system.

Also, we expect pagerank centrality to be linked to convertability in gold. This is because in the 1900s, particularly during the late 19th and early 20th centuries, the gold standard was indeed a prevalent monetary system in many parts of the world. So for trading purposes, talking in gold can be sometimes easier, to have a clearer vision on the value of the goods traded, and so trade negotiation could be more successful between gold convertible money countries.

```{r}
c_page_rank <- page_rank(graph,directed = T, weights = E(graph)$weight)$vector

df <- data.frame(rgdp = V(graph)$rgdp,
                 gold = V(graph)$gold,
                 page_rank = c_page_rank)
```

Now let us see graphically the correlation between the variables and the pagerank centrality.

```{r}
ggplot(df, aes(x = page_rank, y = gold)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)+
  theme_minimal()+
  ggtitle("Pagerank Centrality vs. gold convertability")
```

Apparently, these two variables are positively correlated.

```{r}
ggplot(df, aes(x = page_rank, y = rgdp)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)+
  theme_minimal()+
  ggtitle("Pagerank Centrality vs. Real GDP")
```

Graphically, positive correlation can be seen between rgpd and pagerank value centrality.

We will confirm correlation for both variables with a correlation test.

### Correlation test

```{r}
cor.test(c_page_rank, V(graph)$gold)
```

We get a correlation coefficient of 0.325 with a p-value of 0.029, so we can conclude that, at a 5% level, while being a little low, we cannot deny that we have a positive correlation between having a currency convertible in gold and being influential in the network.

```{r}
cor.test(c_page_rank, V(graph)$rgdp)
```

Here we get a coefficient of 0.617 with a very low p value, thus confirming the correlation between eigen vector centrality and rgpd.

### Centrality visualization

```{r}
par(mfrow=c(1,1), mar=rep(0,4))
colors_rgdp <- scales::dscale(V(graph)$rgdp %>% cut(9), sequential_pal)
sizes_pagerank <- (1:9)[c_page_rank %>% cut(9)] + 1
plot(graph,
     vertex.size = sizes_pagerank,
     vertex.color = colors_rgdp,
     vertex.label = NA,
     edge.color = rgb(0,0,0,.15),
     edge.arrow.size = 0.2,
     )
```

### Degree centrality and being a colonizer

Now we will see if a colonizer node will have a high degree centrality.

Degree centrality is defined by the number of neighbors of a node.

```{r}
c_degree <- degree(graph)

df_degree <- data.frame(is_colonizer = V(graph)$is_colonizer,
                 degree = c_degree)
ggplot(df_degree, aes(x = degree, y = is_colonizer)) +
  geom_point() +
  theme_minimal()+
  ggtitle("Degree Centrality vs. being a colonizer")
```

As we can see, colonizers have high degree centrality.

That was expected since a colonized country have many economic, financial, and political relations with the colonizer, and so they would use the colonizer's currency for their trades, especially since colonizer usually tend to export and import a lot from and to the colony.

## Finding communities

Being in the case of a directed graph, supposing also that a country with many trade edges has thus a powerful currency, and so powerful countries should attract a lot of less powerful countries to them. We expect to find clusters of:

1.  powerful currency countries

2.  countries with low money power

3.  and maybe a third class of in-between countries

Our graph is both directed and weighted, with both weights and directions being very important.

Since in R there is no methods implemented to take into account both weights and directions together to detect communities, we will find clusters with the undirected version of our graph, thus losing important information, to try using multiple clustering methods as the ones learned in the course, and compare their results to choose the best number of communities.

We will use the Greedy, Louvain and Leiden clustering algorithms to detect communities here, which only work on undirected graphs.

```{r}
#We start by making the graph undirected
graph_net <- as.undirected(graph, mode = "mutual")

#Then we apply community detection algorithms
graph_greedy <- cluster_fast_greedy(graph_net, weights = E(graph_net)$weight)
graph_louvain <- cluster_louvain(graph_net, weights = E(graph_net)$weight)
graph_leiden <- cluster_leiden(graph_net, objective_function = "modularity",weights = E(graph_net)$weight)

#We store them in a dataframe to compare them
graph_modularity_res <- data.frame(Algorithm = "Greedy", Modularity = modularity(graph_greedy),Nb_clusters = max(graph_greedy$membership))
graph_modularity_res <- rbind(graph_modularity_res, c("Louvain", modularity(graph_louvain), max(graph_louvain$membership)))
graph_modularity_res <- rbind(graph_modularity_res, c("Leiden", graph_leiden$quality, max(graph_leiden$membership)))
graph_modularity_res
```

Having the same modularity index, let us check how similar those communities are. To do so, we will calculate the Rand Index of similarity for each pair.

```{r}
rand_index <- function(clustering1, clustering2) {
  n <- length(clustering1)
  # Compute the number of agreements and disagreements
  agree <- 0
  disagree <- 0
  
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      if ((clustering1[i] == clustering1[j] && clustering2[i] == clustering2[j]) ||
          (clustering1[i] != clustering1[j] && clustering2[i] != clustering2[j])) {
        agree <- agree + 1
      } else {
        disagree <- disagree + 1
      }
    }
  }
  
  # Calculate the Rand Index
  rand_index <- agree / (agree + disagree)
  
  return(rand_index)
}
```

```{r}
cat("Greedy-Louvain",rand_index(graph_greedy$membership,graph_louvain$membership))
cat("\n Greedy-Leiden",rand_index(graph_greedy$membership,graph_leiden$membership))
cat("\n Louvain-Leiden",rand_index(graph_louvain$membership,graph_leiden$membership))
```

Those algorithms are very similar. So we will choose one of them, the Greedy, and we will visualize the communities.

```{r}
plot(graph, 
     vertex.size=3, 
     vertex.label.cex=0.8, 
     vertex.color=graph_greedy$membership,  
     vertex.label.color=graph_greedy$membership,
     main=paste("Louvain approach\n(Modularity =", round(modularity(graph_greedy), digits=2),"| Clusters =",max(graph_greedy$membership),")"),
     edge.color = rgb(0,0,0,.25))
```

```{r}
plot(graph,
    mark.groups = graph_greedy,
    vertex.size=3,
    vertex.label.cex=0.4,
    vertex.color=graph_greedy$membership,
    vertex.label.color="black",
    vertex.label.dist=1,
    main=paste("Louvain approach\n(Modularity =", round(modularity(graph_greedy), digits=2),"| Clusters =",max(graph_greedy$membership),")"),
    edge.color = rgb(0,0,0,.25))
```
